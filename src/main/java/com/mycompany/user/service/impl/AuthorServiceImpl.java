package com.mycompany.user.service.impl;

import com.mycompany.user.dto.AuthorDto;
import com.mycompany.user.dto.request.GeneralPageRequest;
import com.mycompany.user.dto.response.AuthorPageResponse;
import com.mycompany.user.entity.Author;
import com.mycompany.user.exception.NotFoundException;
import com.mycompany.user.repository.AuthorRepository;
import com.mycompany.user.service.AuthorService;
import org.modelmapper.ModelMapper;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.CachePut;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

@Service
public class AuthorServiceImpl implements AuthorService {

	private final AuthorRepository authorRepository;
	private final ModelMapper modelMapper;

	public AuthorServiceImpl(AuthorRepository authorRepository, ModelMapper modelMapper) {
		this.authorRepository = authorRepository;
		this.modelMapper = modelMapper;
	}

	@Transactional(readOnly = true, propagation = Propagation.SUPPORTS)
	@Override
	public AuthorPageResponse getAuthorListByPage(GeneralPageRequest request) {
		int pageNumber = request.getPageNumber() < 1 ? 1 : request.getPageNumber();
		int pageSize = request.getPageSize() < 1 ? 10 : request.getPageSize();

		Pageable pageable = PageRequest.of(pageNumber - 1, pageSize);
		Page<Author> page = authorRepository.findAll(pageable);

		List<AuthorDto> authors = page.getContent().stream()
				.map(this::convertToDto)
				.collect(Collectors.toList());

		return new AuthorPageResponse(authors, pageNumber, page.getTotalElements(), page.getTotalPages());
	}

	@Transactional(readOnly = true, propagation = Propagation.SUPPORTS)
	@Override
	@Cacheable(value = "authors", key = "#id")
	public AuthorDto findAuthorById(Long id) {
		// Fetch the author from the database
		Author author = authorRepository.findById(id)
				.orElseThrow(() -> new NotFoundException(String.format("Author not found with ID %d", id)));
		// Convert to DTO and return
		return convertToDto(author);
	}

	@Override
	@Transactional
	//@CachePut(value = "authors", key = "#author.id")
	/*Avoid Caching on Creation: For methods like createAuthor,
	caching is not applicable as caching is relevant for retrieval and not creation*/
	public void createAuthor(AuthorDto authorDto) {
		Author author = convertToEntity(authorDto);
		// Ensure ID is not set or is null, as it should be generated by the database
		if (author.getId() != null) {
			throw new IllegalArgumentException("ID should not be set for new authors");
		}
		authorRepository.save(author);
	}

	@Override
	@Transactional
	@CachePut(value = "authors", key = "#authorDto.id")
	public void updateAuthor(AuthorDto authorDto) {
		if (!authorRepository.existsById(authorDto.getId())) {
			throw new NotFoundException(String.format("Author not found with ID %d", authorDto.getId()));
		}
		Author author = convertToEntity(authorDto);
		// Ensure ID is set correctly
		authorRepository.save(author);
	}

	@Override
	@Transactional
	@CacheEvict(value = "authors", key = "#id")
	public void deleteAuthor(Long id) {
		Author author = authorRepository.findById(id)
				.orElseThrow(() -> new NotFoundException(String.format("Author not found with ID %d", id)));
		authorRepository.deleteById(author.getId());
	}

	private AuthorDto convertToDto(Author author) {
		return modelMapper.map(author, AuthorDto.class);
	}

	private Author convertToEntity(AuthorDto authorDto) {
		return modelMapper.map(authorDto, Author.class);
	}
}
